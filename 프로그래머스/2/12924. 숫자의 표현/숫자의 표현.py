def solution(n):
    '''
    숫자를 연속적으로 더할 때 시작 값이 주어진 자연수의 반 이상이 되는 경우
    어차피 더해도 주어진 숫자 n보다 큰 값이 나옵니다.
    ex) 7+8>14, 6+7>12 | 7+8>13, 8+9>15 | n이 홀수일 때 절반보다 큰 7에서 시작하면
    6+7==13이므로 초과하지 않기에 절반+2를 해주어 하나 더 큰 곳까지 확인하도록 해줍니다.
    그래서 n이 짝수면 (n//2)+1, 홀수면 (n//2)+2 까지만 반복문을 돕니다.
    그리고 최대한 많은 숫자로 주어진 숫자를 만들려면 작은 숫자부터 더해주고,
    최소한의 개수로 주어진 숫자를 만들려면 큰 숫자부터 더해줍니다.
    '''
    # 자기 자신을 넣었을 때 1가지를 방법 초기값으로 설정, 자연수 배열
    r,t=1,[]
    # 2까지는 자기 자신을 넣는 1가지만 가능합니다.
    if n<=2:
        r=1
    # 값을 절반으로(2로) 나누기에 3부터 아래 반복문이 정상 동작합니다.
    else:
        for i in range(1,(n//2)+2):
            t+=[i]
            if sum(t)>n:
                while sum(t)>n:
                    del t[0]
            if sum(t)==n:
                r+=1
    return r