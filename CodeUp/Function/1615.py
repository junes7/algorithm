# 셀프 넘버(Self-Number)
# 어떤 자연수 n이 있을 때, d(n)을 n의 각 자릿수 숫자들과 n 자신을 더한
# 숫자라고 정의하자. 예를 들어 d(91) = 9 + 1 + 91 = 101일 때, n을 d(n)
# 의 제네레이터(generator)라 한다. 어떤 숫자들은 하나 이상의 제네레이터를
# 가지고 있는데, 101의 제네레이터는 91뿐 아니라 100도 있다. 그런데 반대로,
# 제네레이터가 없는 숫자들도 있으며, 이런 숫자를 인도의 수학자 Kaprekar가
# 셀프 넘버(self-number)라 이름 붙였다.
# 즉, 셀프 넘버란 앞에서 나온 특정 규칙으로 계산되는 숫자가 아닌 오로지
# 자가 자신으로만 고유한 숫자를 말한다.
# 예를 들어 1은 어떠한 수를 더해도 1을 만들 수 없다. 생성자가 없다.
# 즉, 1은 고유한 것이다.
# 반면에 2의 경우 규칙을 통해 1+1로 만들어지기 대문에 고유하지 않다고
# 판명한다. 1은 2의 생성자가 되기 때문이다.
# 예를 들어 1, 3, 5, 7, 9, 20, 31은 셀프 넘버 들이다.
# 먼저 배열을 선언한다. 이 배열은 셀프 넘버가 아닌 것들을 체크할 것이다.
# 반복문 5000까지 돌리면서 숫자가 셀프 넘버가 아니면 배열에 true 해준다.
# 체크 완료 되면 반복문 다시 돌려서 배열에서 false인 값들을 출력한다.
# 시작 값(a)과 마지막 값(b)가 입력되면 두 수 사이의 셀프 넘버들의 합 출력
# method 1
a, b = map(int, input().split())
d = [0] * 5100
def f(n):
    s = n
    while n != 0:
        s += n % 10
        n //= 10
    return s
for i in range(1, 5001):
    n = f(i)
    d[n] = 1
sum = 0
for j in range(a, b+1):
    if d[j] != 1:
        sum += j
print(sum)